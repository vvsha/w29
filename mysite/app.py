#!/usr/bin/env python
# Mindblown!
#
# Mashup of tornado with Websockets, sending objects serialized with
# protobuf and receiving them in a REQ-REP zeromq setup
#
import sys
from tornado import websocket, web
sys.dont_write_bytecode = True      # Prevent generation of .pyc
                                    # on the next import
from example_pb2 import Message     # Autogenerated by protoc
import zmq
from zmq.eventloop.zmqstream import ZMQStream
from zmq.eventloop import ioloop
from google.protobuf import text_format

cl = []


class IndexHandler(web.RequestHandler):
    def get(self):
        self.render("index.html")


class SocketHandler(websocket.WebSocketHandler):
    def open(self):
        if self not in cl:
            cl.append(self)

    def on_close(self):
        if self in cl:
            cl.remove(self)


def recv_callback_stream(stream, data):
    m = Message()
    m.ParseFromString(data[0])

    print 'received message: ' + \
          text_format.MessageToString(m, as_utf8=True, as_one_line=True)

    # Do something clever with the message ...
    m.value = m.value + ' :) '

    print 'modified message: ' + \
        text_format.MessageToString(m, as_utf8=True, as_one_line=True)
    # Send it through all sockets connected
    for c in cl:
        c.write_message(m.SerializeToString())
    # Send modified message back to client as an answer
    stream.send_multipart([m.SerializeToString()])


def periodic_callback():
    # Change a random cell, for example (left as exercise for the reader)
    pass

# Setup handlers for tornado

handlers_array = [
    (r'/', IndexHandler),
    (r'/ws', SocketHandler)]

# Static files served with tornado
for path in ['favicon.ico', 'rest_api_example.png',
             'bootstrap-combined.no-icons.min.css', 'ProtoBuf.min.js',
             'ByteBuffer.min.js', 'Long.min.js', 'jquery.min.js',
             'example.proto']:
    handlers_array += [(r'/(' + path + ')', web.StaticFileHandler,
                       {'path': './'})]

app = web.Application(handlers_array)


if __name__ == '__main__':
    if len(sys.argv) == 1:
        print 'Usage ./app.py <server | client <number> <id> <value>>'
        sys.exit(0)

    if sys.argv[1] == 'server':
        # Setup a REP ZMQ socket
        context = zmq.Context()
        socket = context.socket(zmq.REP)
        socket.bind('tcp://127.0.0.1:8889')
        # See http://zeromq.github.io/pyzmq/eventloop.html

        # Setup the event loop
        # loop = tornado.ioloop.IOLoop.instance()
        ioloop.install()

        # Add a ZMQStream made from the socket to the event loop
        stream = ZMQStream(socket)

        # Register recv callback
        stream.on_recv_stream(recv_callback_stream)

        # How to add a periodic callback to the event loop
        periodic = ioloop.PeriodicCallback(periodic_callback, 1000)

        # periodic_callback will be called each second
        periodic.start()

        # Setup tornado webserver on :8888
        app.listen(8888)
        # And start the event loop
        print 'Open a browser to http://localhost:8888'
        ioloop.IOLoop.instance().start()

    elif sys.argv[1] == 'client':
        if len(sys.argv) != 5:
            print 'Usage: ./app.py client <number> <id> <value>'
            sys.exit(0)

        # Fill and serialize message
        m = Message()
        m.no = int(sys.argv[2])
        m.id = sys.argv[3]
        m.value = sys.argv[4]

        # Actual buffer to be sent
        data = m.SerializeToString()

        # Setup client socket
        context = zmq.Context()
        socket = context.socket(zmq.REQ)
        socket.connect('tcp://127.0.0.1:8889')

        socket.send_multipart([m.SerializeToString()])
        msg = socket.recv_multipart()
        print 'received back: ' + \
            text_format.MessageToString(msg[0], as_utf8=True, as_one_line=True)
